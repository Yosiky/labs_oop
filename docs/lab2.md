# ООП лабораторная 2

## Наследование

Это один из ключевых принципов ООП, позволяющий использовать перменные и
методы другого класса как свои собственные.

> Класс **родитель (базовый)** - это класс, от которого будут наследоваться
> данные и методы.  
> **Дочерний** класс **(производный)** - это класс, который наследует данные из
> класса родителя.

### Атрибут доступа protected

> Ключевое слово `protected` - говорит, что всё объявленное ниже данного
> слова будет недоступно из вне класса, но дочерние классы могут использовать.

#### Пример наследования

```c++
class Figure {
protected:
    string name;

    void showInfo() const {
        cout << "Figure: " << name << endl;
    }

public:
    Figure(const string &n="figure") : name(n) { }
    ~Figure() = default; /* TODO */ 
};

class Circle : public Figure {
public:
    Circle() : Figure("circle")
    {
        swowInfo(); /* It works */
    }
};

int main() {
    Figure f;
    f.name;
    f.showInfo(); /* doesn't work because this method is marked as protected */

    Circle c;
    c.name;
    c.showInfo(); /* doesn't work too because this method is marked as protected too */
}
```

### Преобразование доступа в зависимости от способа наследования

При наследование атрибуты и методы изменяют свои права доступа в зависимости
от способа наследования. Ниже в таблицах приведены преобразования.

> Подробнее Вы посмотреть и поэксперемнтировать можете в файле 
"[src/lab2/base_inheritance.cpp](../src/lab2/base_inheritance.cpp)".

#### Public наследование
| Тип в классе родителя -> Тип в классе ребенке |
| :-------------------------------------------: |
|               private -> private              |
|             protected -> protected            |
|                public -> public               |

#### Private наследование
| Тип в классе родителя -> Тип в классе ребенке |
| :-------------------------------------------: |
|               private -> private              |
|             protected -> private              |
|                public -> private              |

#### Protected наследование
| Тип в классе родителя -> Тип в классе ребенке |
| :-------------------------------------------: |
|               private -> private              |
|             protected -> protected            |
|                public -> protected            |

## Полиморфизм

Это способность кода работать с разными классами используя один интерфейс.

### Виртуальные методы (`virtual`, `override`, `final`)

> `virtual` - говорит, что функция может быть перегружена в дочерних классах.  
> `override` - говорит, что функция перегружает родительскую. И что эта функция
> может быть тоже перегружена в дочерних классах.  
> `final`  - говорит, что функция перегружает родительскую, но в дочерних классах
> уже нельзя будет это сделать. TODO.

**НИКОГДА** не используйте виртуальные методы внутри конструктора, это ведето к 
**UB (Undefine Behavior)**.  
Cсылка: [докумнетация почему нельзя вызывать виртуальный методв внутри конструктора](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#Rc-ctor-virtual)  
Ссылка: [как все-таки можно вызвать виртуальный метод внутри конструктора](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#Rc-factory)

#### Динамический полиморфизм

В динамическом полиморфизме используют принципы наследования совместно с
виртуальными функциями.

> **P.S.**: файл с примером ниже "[src/lab2/virtual_methods.cpp](../src/lab2/virtual_methods.cpp)"
```c++
class Figure {
public:
    virtual void showInfo() const {
        cout << "Base class Figure" << endl;
    }
};

class Circle : public Figure {
public:
    void showInfo() const override { /* You don’t need to write virtual if you write override */
        /* Implementation for Circle */
        cout << "Derived class Circle" << endl;
    }
};

class Square : public Figure {
public:
    void showInfo() const override {
        /* implementation for Square */
        cout << "Derived class Square" << endl;
    }
};

int main() {
    {
        Figure *anonim = new Figure(/* parameters */);
        anonim->showInfo();
    }
    {
        Figure *anonim = new Circle(/* parameters */);
        anonim->showInfo(); /* What will we see? */
    }
    {
        Figure *anonim = new Square(/* parameters */);
        anonim->showInfo(); /* What will we see? */
    }
}
```


#### Статический полиморфизм

Помимо динамического полиморфизма существует еще и статический в его основе
лежити спользование шаблонов.

> Про шаблоны мы будем говорить в последующих лабораторных. Здесь они 
> используются исключительно в качестве примера.

```c++
template <class S>
void printContainer(S &container) {
    for (const auto &it : container) {
        std::cout << it << std::endl;
    }
}

int main() {
    vector<int> v({1, 2, 3});
    list<int> l({4, 5, 6});

    printContainer(v);
    printContainer(l);
}
```

### Абстрактные классы

> **Абстрактные классы** - выступают в роли интерфейса, которому должны следовать
> все дочерние классы. Что бы класс считался абстактным ему необходимо иметь
> хотя бы одну **чисто виртуальную** функцию (как это делается приведено ниже).
> Так же следует запомнить, что в классах наследниках должны быть перегружены
> все чисто виртуальные функции, иначе у Вас не получится создать экземпляр класса.

Создание абстрактного класса делается следующим образом.

> **P.S.**: подробнее можно посмтореть в файле "[scr/lab2/abstract_class.cpp](../scr/lab2/abstract_class.cpp)"

```c++
class Figure {
public:
    virtual void printInfo(void) const = 0; /* You must to mark a function "<func> = 0" */
};

/*
 * If you don't say a type of inheritance, then the type will be used default:
 * - public for structs
 * - private for classes
 */
struct Circle : Figure {
    void printInfo(void) const override {
        std::cout << "It's Circle" << std::endl;
    }
};

struct Square : Figure {

    /* If function will be uncommented we don't get error in main() */
    // void printInfo(void) const override {
    //     std::cout << "It's Square" << std::endl;
    // }
};

int main() {
    Circle circle;
    Square square; /* We get error because printInfo() isn't overrided in Square */

    circle.printInfo();
    square.printInfo();
}

```

## Преобразование типов

Для явного преобразования типов в C++ принято использовать следующие операторы:
- `static_cast`
- `dynamic_cast`
- `const_cast`
- `reinterpret_cast`

### static_cast

> `static_cast` - используется, когда вы знаете тип приводимого объекта.

В большинстве случаев, если Вы не знаете какой каст следует исопльзовать,
то вам необходим `static_cast`.

```c++
class Figure;
class Circle;

int main() {
    Circle c;
    Figure *ptr = static_cast<Figure *>&c;
}
```

### dynamic_cast

> `dynamic_cast` - использутеся, когда вы точно не знаете тип приводимого объекта.

```c++
class Figure;
class Circle;
class Square;
class Rectangle;

template <class T>
T *createFigure() {
    return new T;
}

int main() {
    Figure *ptr_circle = dynamic_cast<Figure *>(createFigure<Circle>());
    Figure *ptr_square = dynamic_cast<Figure *>(createFigure<Square>());
    Figure *ptr_rectangle = dynamic_cast<Figure *>(createFigure<Rectangle>());

    ptr_circle->figureInfo();
    ptr_square->figureInfo();
    ptr_rectangle->figureInfo();
}
```

### const_cast

> `const_cast` - используется, когда вы хотите снять или добавить модификатор `const`.

**НЕ ИСПОЛЬЗУЙТЕ** `const_cast` для снятия `const` у объекта.  
Ссылка: [почему не стоит так делать](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#es50-dont-cast-away-const)

В большинстве случаев использование `const_cast` подразумевает не правильную
архитектуру вашей программы.

### reinterpret_cast

> `reinterpret_cast` - 

### Преобразование в C-style

Данные преобразование **НЕ рекомендуется** для использовать при написании на **С++**.

> **P.S.**: пример можно посмотреть в "[src/lab2/c_cast.cpp](src/lab2/c_cast.cpp)"

```c++
int main() {
    /* My machine use LITTLE ENDIAN */
    long long a = 0x0000'0000'414c'4f48; /* HOLA */
    char *str = (char *)&a; /* C-style cast */

    printf("%s\n", str);
}
```

# Задания

## Aaaaaaand... OPEN!

### Дополнительные условия

Ваша программа должно состоять из следующих файлов:
`FragTrap.cpp` `FragTrap.hpp` `main.cpp`

### Основная часть задания

В этом задании Вы сделаете класс, соответсвующий FR4G-TP атакуют роботов.

Класс будет называться `FragTrap` и у него будут следующие атрибуты, инициализирующиеся
с заранее заданными значениями:
- Здоровье (100)
- Максимальное кол-во здоровья (100)
- Очки энергии (100)
- Максимальное кол-во очков энергии (100)
- Уровень (1)
- Имя (аргумент конструктора)
- Урон вблизи (30)
- Урон издалека (20)
- Броня, уменьшающая урон (5)

Также необходимо добавить несколько методов, они нам понадобятся в дальнейшем:
- `rangedAttack(std::string const &target)`
- `meleeAttack(std::string const &target)`
- `takeDamage(unsigned int amount)`
- `beRepaired(unsigned int amount)`

Все перечисленные выше методы должны печатать некую информацию, описывающую
что случилось. Например, метод `rangedAttack()` может печатать что-то похожее на

```bash
$ FR4G-TP <name> attacks <target> at range, causing <damage> points of damage!
```

Конструкторы и деструктор должны также печатать что-нибудь, так людям будет проще
понять что вызывается при исполнении программы.

### Ограничения:
- Значение здоровья не может быть больше максимального кол-во здоровья. Аналогично
и для шкалы энергии. Например, если вы восстановили слишком много HP, то необходимо
выставить значение как максимальное значение. Также оно не может быть меньше нуля.
- Когда получаете урон, вам надо вычитывать значение брони из атаки.

В завершении добавим метод `vault_hunter_dot_exe(std::string const &target)`,
осуществляющий полуслучайную атаку на цель. Сделайте так, чтобы при каждом
вызове выбиралась (предпочтительно) забавная атака, выбранная случайным
образом из как минимум 5 возможных атак. Можете исползовать всё что хотите
для достижения этой цели, но, как обычно, чем элегантнее ваш метод, тем лучше.
Выполнение этой функции требует 25 единиц энергии. И если у вас недостаточно
очков энергии, программа просто напечатает сообщение о том, что у
Вас нехватает энергии.

Самостоятельно напишите `main` функцию с тестами, демонстрирующими что ваш код
исправно работает.


## Serena, my love!

### Дополнительные условия

Ваша программа должно состоять из следующих файлов:
Файлы из предыдущего задания + `ScavTrap.cpp` `ScavTrap.hpp`

### Основная часть задания

Поскольку нам всегда не хватает ловушек, теперь вы создадите еще одну,
которая будет служить несколько иной цели: охранять дверь вашего
будущего логова зла и бросать вызов людям, которые захотят войти

Класс будет называться `ScavTrap` со следующими атрибутами:
- Здоровье (100)
- Максимальное кол-во здоровья (100)
- Очки энергии (50)
- Максимальное кол-во очков энергии (50)
- Уровень (1)
- Имя (аргумент конструктора)
- Урон вблизи (20)
- Урон издалека (15)
- Броня, уменьшающая урон (3)

Также необходимо добавить методы как и в `FragTrap`, но конструктор, деструктор и
методы атаки должны иметь другую печать. В конце концов, ловушка должна обладать
некой индивидуальностью.

Единственным исключением будет то, что в `ScavTrap` не будет иметь метод
`vaulthunter_dot_exe()`. Вместо него, здесь будет метод `challengeNewcomer()`,
выбирающая псевдослучайной испытание, придуманное тобой, и печатать
его в консоль.

Добавьте в свою `main` функцию новые тесты, покрывающие новый функционал.

## Repetitive work

### Дополнительные условия

Ваша программа должно состоять из файлов созданных в предыдущих заданиях +
к ним добавляются `ClapTrap.cpp` и `ClapTrap.hpp`.

### Основная часть задания

Возможно создание различных ловушек Вам начинает надоедать, не так ли?

Но прежде чем начать работать меньше, надо поработать побольше =)

В этом задании Вам предстоит создать класс `ClapTrap`, от которого будут
наследоваться классы `FragTrap` и `ScavTrap` из предыдущих заданий.

Общие методы реализованных ранее классов, надо переместить в новый класс
`ClapTrap`, но отличающиеся методы должны остаться на месте. Другими словами
классы `FragTrap` и `ScavTrap` должны содержать методы, которые они не делят
между собой, а общие методы для этих классов должны находиться в родительском
классе.

Также класс `ClapTrap` имеет свои сообщения в конструкторе и деструкторе.

## Now it's easier!

### Дополнительные условия

Ваша программа должно состоять из файлов созданных в предыдущих заданиях +
к ним добавляются `NinjaTrap.cpp` и `NinjaTrap.hpp`.

### Основная часть задания

Используя всё что было реализовано ранее, сделайте `NinjaTrap`, со следующими
атрибутами:
- Здоровье (60)
- Максимальное кол-во здоровья (60)
- Очки энергии (120)
- Максимальное кол-во очков энергии (120)
- Уровень (1)
- Имя (аргумент конструктора)
- Урон вблизи (60)
- Урон издалека (5)
- Броня, уменьшающая урон (0)

Специальная атака будет `ninjaShoebox()`. Необходимо создать несколько методов
принимающих различные `ClapTrap`, реалзиованные ранее, как параметр (включая
`NinjaTrap`) и делают разные действия. Жаль что нет способа заставить принимать
ЛЮБОЙ `ClapTrap`, но при этом реагировать определенным способом... Но это
вы увидете позднее.

Как обычно, надо самостоятельно написать `main()` для тестирования нового класса.

Обратили ли вы внимание как просто было сделать новый класс с использованием
родительского класса `ClapTrap`?

## Ultimate assault shoebox

### Дополнительные условия

Ваша программа должно состоять из файлов созданных в предыдущих заданиях +
к ним добавляются `SuperTrap.cpp` и `SuperTrap.hpp`.

### Основная часть задания

Сейчас, Вы будете комбинировать лучшие вещи из ранее созданных классаов, а
именно половина из `FragTrap` и `NinjaTrap`.

Класс должен называться `SuperTrap` и будет наследоваться из `FragTrap` и `NinjaTrap`.

Значения атрибутов и функций будет выбрано из обоих родительских классов:
- Здоровье (`FragTrap`)
- Максимальное кол-во здоровья (`FragTrap`)
- Очки энергии (`NinjaTrap`)
- Максимальное кол-во очков энергии (`NinjaTrap`)
- Уровень (1)
- Имя (аргумент конструктора)
- Урон вблизи (`FragTrap`)
- Урон издалека (`FragTrap`)
- Броня, уменьшающая урон (`FragTrap`)
- `rangedAttack()` (`FragTrap`)
- `meleeAttack()` (`NinjaTrap`)

Как обычно, надо самостоятельно написать `main()` для тестирования нового класса.

Также `ClapTrap` часть в `SuperTrap`, должна создаваться единожды.