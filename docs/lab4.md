# ООП лабораторная №4

## Шаблоны

A usefule link: https://habr.com/ru/articles/599801/#_1_FunctionTempates

Давайте представим, что у нас есть тип `MyType`, для которого переопределен оператор сравнения `<`.
И нам надо написать функцию `min`, принимющую наш тип в качестве аргумента.

```c++
MyType min(MyType lft, MyType rht) {
    return lft < rht ? lft : rht;
}
```

А теперь, пускай к нам добавили еще классов, или нам надо какой-то из
базовых типов, например `int`. Что бы это сделать нам потребуется
перегрузить функцию `min`.

В результате получим что-то такое:

```c++
MyType min(MyType lft, MyType rht) {
    return lft < rht ? lft : rht;
}

int min(int lft, int rht) {
    return lft < rht ? lft : rht;
}
```

Как можно увидеть, теперь у нас объявлены и определены 2 функции.
И если нам потребуется поправить условие, то надо будет править
каждую функцию. Что является не очень удобным.

Поэтому для избежания дублирования кода используют **шаблоны**.

`шаблон` - возможность языка, позволяющая описывать обобщенные алгоритмы
без привязки к типам данных или размерам буффера.

В с++ возможно создавать шаблоны функций и классов.

## Шаблоны функций

```c++
template <class T>
T min(T lft, T rht) {
    return lft < rht ? lft : rht;
}

int main(void) {
    int a = 5, b = 10;
    std::cout << min(a, b); /* print 5 */

    float a = 1.5, b = 3.14;
    std::cout << min(a, b); /* prints 1.5 */
}
```

И если же мы захотим использовать написанную шаблонную функцию для нашего
типа `MyType`достаточно просто передать объекты этого типа в эту функцию.

```c++
int main(void) {
    MyType a, b;
    /* ... */
    min(a, b); /* use type MyType */
}
```

Так же есть возможность явно указать какой тип будет использоваться
при вызове функции.
```c++
int main()
    float a = 1.5, b = 3.14;

    std::cout << min<int>(a, b); /* prints 1 */
```

в данном случае будет вызвана функция `int min(int, int)`, и оба аргумента
приведутся из `float` к типу `int`.

### Специализация шаблонов функций

Бывает, что какой-то тип имеет специфическое поведение, которое надо учитывать
в шаблонной функции. Для этого можно сделать специализацию шаблона для этого типа.

```c++
template <calss T>
T min(T lft, T rht) {
    return lft < rgh ? lft : rht;
}

template <>
string min<string>(string lft, string rht) {
    return lft.size() < rht.size() : lft : rht;
}

int main(void) {
    std::cout << min<string>("hello", "hola");
}
```

В таком случае при вызове функции от типа `string` будет вызвана специфичная
реализация, а для других типов - общая.

### Шаблоны методов / конструкторов / операторов

Так как методы класса и операторы яаляются функциями, к ним тоже применимы шаблоны:

```c++
class MyString {
    std::string str;

public:
    template <class T>
    String(const T &init) {
        str = std::to_string(init); // convert any type to string
    }

    template <class T>
    String &operator +=(const T &other) {
        str += std::to_string(other);
        return *this;
    }

    template <class T>
    String join(const T &array) { // like Python's str.join() method
        String ret;

        for (auto val : array) {
            ret += val;
            ret += str;
        }

        return ret;
    }
};
```

### Шаблоны с несколькими типами

При указании типа `T` в шаблоне - все переменные типа `T` будут иметь одинаковый
тип при подстановке типов в шаблон на этапе компиляции. Поэтому, если мы
попытаемся передать туда разные типы - то компилятор выдаст ошибку, потому что
он не знает какой из типов выюрать в качестве подстановки (в таком случае
придется явно указывать какой тип мы хотим использовать)

```c++
template <class T>
T min(T a, T b) {
    return a < b ? a : b;
}

int main() {
    int a = 123;
    float b = 2.71;

    std::cout << min(a, b); // error: deduced conflicting types for parameter 'T'

    std::cout << min<float>(a, b); // ok, float will be used for type T
}
```

Но есть возможность указывать несколько типов в шаблоне. В таком случае можно
подставлять любые комбинации типов в параметры шаблона.

```c++
template <class Type1, class Type2>
Type1 min(Type1 a, Type2 b) {
    return a < b ? a : b;
}

int main() {
    int a = 123;
    float b = 4.31;
    char c = 'x';
    double d = 414.13343;

    std::cout << min(a, b); // ok, Type1 = int, Type2 = float
    std::cout << min(b, c); // ok, Type1 = float, Type2 = char
    std::cout << min(c, d); // ok, Type1 = char, Type2 = double

    std::cout << min(a, a); // ok, Type1 = int, Type2 = int
    std::cout << min(b, b); // ok, Type1 = float, Type2 = float
}
```

Так все переменные типа `Type1` будут иметь одинаковый тип, и все переменные
типа `Type2` будут иметь одинаковый тип, но `Type1` и `Type2` могут быть как разными типами, так и одинаковыми.


## Шаблоны классов

Шаблоны можно применять и к классам. Таким образом можно работать с полями
класса независимо от их типа:

```c++
template <class T>
class Point {
    T x;
    T y;

public:
    Point(T xv, T yv)
        : x(xv), y(yv)
    {}

    Point operator +(Point other) { // here we do not need to write Point<T>, just
                                    // Point, and here all Point variables will
                                    // have same type T
        return Point(x + other.x, y + other.y);
    }

    template <class Other>
    Point<Other> operator +(Point<Other> other) { // here we want to add points
                                                  // of different types, so we
                                                  // need to specify type
                                                  // of other point to be
                                                  // different from type T
        return Point<Other>(x + other.x, y + other.y);
    }

    T length(void) {
        return sqrt(x * x + y * y);
    }
};

int main()
{
    Point<int> p(1, 2);
    Point d(1.2, 4.5); // compiler will deduce type to be double
}
```

# Задания

## Удобные функции

Реализуйте следующие функции в виде шаблона:
- `swap` - меняет местами значения в аргументах. Ничего не возвращает.
- `min` - сравнивает аргументы и возвращает наименьшее из них.
Если элементы эквивалентны возвращает второе из них.
- `max` - cравнивает аргументы и возвращает наибольшее из них.
Если элементы экваваленты, то возвращает второй из них.

Функции должны вызываться с любыми аргументов, при условии что они
имеют один тип и поддерживают все операторы сравнения. Обеспечьте
свой код тестами, подтверждающие корректную работу ващего кода.

## Iter

Напишите функцию `iter`, принимающую 3 аргумента и ничего возвращающую.
Параметры:
 - указатель на массив
 - кол-во элементов в массиве
 - фун-ию, которую надо применить для всех элементов

Подвердите работоспособность вашего кода, для этого напишите собственные тесты.

## Array

В этом задании надо написать класс `Array`, содержащий элементы типа `T` и
позволяют следовать следующему поведению:
 - конструктор без параметров: создают пустой массив.
 - конструктор с `unsigned int n`: создает массив из `n` элементов,
 инициализирующие значения по умолчанию (Подсказка: `int *a = new int[...]`,
 и посмотрите значение `*a`).
 - конструктор копирования и оператор присваивания. В обоих случаях,
 изменение одного из массивов после копирования/присваивания,
 не должно влиять на другой.
 - необходимо использовать оператор `new[]` для аллоцирования массива.
 Ваш код не должен обращаться к не выделенной памяти.
 - элементы должны быть доступны через `operator[]`.
 - бросание `std::exception`, если произошел выход за границы массива
 при использовании `operator[]`.
 - `size()`, возвращающий кол-во элеметов в массиве.
 Метод не принимает аргументы и ничего не изменяет в объекте.

Подвердите работоспособность вашего кода, для этого напишите собственные тесты.