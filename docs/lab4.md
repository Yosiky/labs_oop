# ООП лабораторная №4

## Шаблоны

A usefule link: https://habr.com/ru/articles/599801/#_1_FunctionTempates

Давайте представим, что у нас есть тип `MyType`, для которого переопределен оператор сравнения `<`.
И нам надо написать функцию `min`, принимющую наш тип в качестве аргумента.

```c++
MyType min(MyType lft, MyType rht) {
    return lft < rht ? lft : rht;
}
```

А теперь, пускай к нам добавили еще классов, или нам надо какой-то из
базовых типов, например `int`. Что бы это сделать нам потребуется
перегрузить функцию `min`.

В результате получим что-то такое:

```c++
MyType min(MyType lft, MyType rht) {
    return lft < rht ? lft : rht;
}

int min(int lft, int rht) {
    return lft < rht ? lft : rht;
}
```

Как можно увидеть, теперь у нас объявлены и определены 2 функции.
И если нам потребуется поправить условие, то надо будет править
каждую функцию. Что является не очень удобным.

Поэтому для избежания дублирования кода используют **шаблоны**.

`шаблон` - возможность языка, позволяющая описывать обобщенные алгоритмы
без привязки к типам данных или размерам буффера.

В с++ возможно создавать шаблоны функций и классов.

### Шаблоны функций

```c++
template <class T>
T min(T lft, T rht) {
    return lft < rht ? lft : rht;
}

int main(void) {
    int a = 5, b = 10;
    std::cout << min(a, b); /* print 5 */

    float a = 1.5, b = 3.14;
    std::cout << min(a, b); /* prints 1.5 */
}
```

И если же мы захотим использовать написанную шаблонную функцию для нашего
типа `MyType`достаточно просто передать объекты этого типа в эту функцию.

```c++
int main(void) {
    MyType a, b;
    /* ... */
    min(a, b); /* use type MyType */
}
```

Так же есть возможность явно указать какой тип будет использоваться
при вызове функции.
```c++
int main()
    float a = 1.5, b = 3.14;

    std::cout << min<int>(a, b); /* prints 1 */
```

в данном случае будет вызвана функция `int min(int, int)`, и оба аргумента
приведутся из `float` к типу `int`.

### Специализация шаблонов

Бывает, что какой-то тип имеет специфическое поведение, которое надо учитывать
в шаблонной функции. Для этого можно сделать специализацию шаблона для этого типа.

```c++
template <calss T>
T min(T lft, T rht) {
    return lft < rgh ? lft : rht;
}

template <>
string min<string>(string lft, string rht) {
    return lft.size() < rht.size() : lft : rht;
}

int main(void) {
    std::cout << min<string>("hello", "hola");
}
```

В таком случае при вызове функции от типа `string` будет вызвана специфичная
реализация, а для других типов - общая.

### Шаблоны классов

# Задания

## Удобные функции

Реализуйте следующие функции в виде шаблона:
- `swap` - меняет местами значения в аргументах. Ничего не возвращает.
- `min` - сравнивает аргументы и возвращает наименьшее из них.
Если элементы эквивалентны возвращает второе из них.
- `max` - cравнивает аргументы и возвращает наибольшее из них.
Если элементы экваваленты, то возвращает второй из них.

Функции должны вызываться с любыми аргументов, при условии что они
имеют один тип и поддерживают все операторы сравнения. Обеспечьте
свой код тестами, подтверждающие корректную работу ващего кода.

## Iter

Напишите функцию `iter`, принимающую 3 аргумента и ничего возвращающую.
Параметры:
 - указатель на массив
 - кол-во элементов в массиве
 - фун-ию, которую надо применить для всех элементов

Подвердите работоспособность вашего кода, для этого напишите собственные тесты.

## Array

В этом задании надо написать класс `Array`, содержащий элементы типа `T` и
позволяют следовать следующему поведению:
 - конструктор без параметров: создают пустой массив.
 - конструктор с `unsigned int n`: создает массив из `n` элементов,
 инициализирующие значения по умолчанию (Подсказка: `int *a = new int()`,
 и посмотрите значение `*a`).
 - конструктор копирования и оператор присваивания. В обоих случаях,
 изменение одного из массивов после копирования/присваивания,
 не должно влиять на другой.
 - необходимо использовать оператор `new[]` для аллоцирования массива.
 Ваш код не должен обращаться к не выделенной памяти.
 - элементы должны быть доступны через `operator[]`.
 - бросание `std::exception`, если произошел выход за границы массива
 при использовании `operator[]`.
 - `size()`, возвращающий кол-во элеметов в массиве.
 Метод не принимает аргументы и ничего не изменяет в объекте.

Подвердите работоспособность вашего кода, для этого напишите собственные тесты.